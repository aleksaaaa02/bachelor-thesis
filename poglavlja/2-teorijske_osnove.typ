#import "../funkcije.typ":todo

= Спецификација система и теоријске основе 
<teorijske_osnove>

== ОСИ модел и мрежни протоколи

OSI модел представља концептуални модел који описује како различити делови мрежних система комуницирају један са другим. Модел је подељен на седам слојева: физички слој, слој везе, мрежни слој, транспортни слој, слој сесије, слој презентације и слој апликације. У контексту мултиплејер игара, посебан акценат ставља се на транспортном слоју, јер они одређују како подаци путују од сервера до клијента и обрнуто. Два најчешћа протокола су TCP (_Transmission Control Protocol_) и UDP (_User Datagram Protocol_) @iso7498_1_1994.

IP је протокол мрежног слоја који омогућава пренос и рутирање података преко интернета. Подаци се деле на мање јединице -- пакете, при чему сваки пакет садржи информације о адресама извора и одредишта, што омогућава његово правилно усмеравање кроз мрежу. Сваки повезан на интернет има своју јединствену IP адресу, а пакети се шаљу и примају управо на основу тих адреса. Када пакет стигне на одредиште, његова обрада зависи од транспортног протокола који се користио. Најчешћи мрежни протоколи транспортног слоја су TCP и UDP @cloudflareip.

TCP је поуздан протокол који обезбеђује да сваки пакет података стигне до примаоца у исправном редоследу, контролише грешке и поново шаље изгубљене пакете. TCP се користи за податке који морају бити потпуно тачни и где је битно да порука буде испоручена. Добар пример коришћења овог протокола су информације о пријављивању на систем, системи за дописивање или други критични подаци који не смеју бити изгубљени @tcp.

UDP је протокол без гаранције редоследа или поузданости испоруке пакета. Углавном је много бржи од TCP-a јер не врши потврду примања и нема контролу грешака. Због тога је UDP погодан за податке у реалном времену у мултиплејер видео-играма, као што су позиције играча, акције или брзи догађаји, где је важнија брзина од поузданости. Још једно место где се UDP користи је у системима за ћаскања уживо, пример оваквог система је _Discord_ @discordvoip. Често се за UDP може пронаћи израз "_пошаљи и заборави_" (енг. "_fire and forget_") @avastfireandforget.

У мултиплејер играма, иако UDP преовладава, могућа је комбинација оба протокола: TCP за критичне податке, а UDP за ажурирање стања света у реалном времену. Ова комбинација омогућава и поузданост и висок ниво перформанси.

== Rust

_Rust_ је модеран програмски језик који се истиче по безбедном руковању меморијом, конкурентности и високом нивоу перформанси, где се често пореди са перформансама које достижу C и C++. Ове особине га чине изузетно погодним за развој мултиплејер игара, где је потребно управљати великим бројем истовремених веза и обрађивати податке у реалном времену.

Један од кључних предности _Rust_-a је безбедност на нивоу компајлера, који спречава грешке попут двоструког ослобађања меморије или међусобног блокирања (енг. _deadlock_). Концепти као што су власништво, позајмљивање и животни век омогућавају креирање стаблиних и поузданих система без додатних провера у време извршавања. Све ове функционалност обезбеђене су од стране _borrow checker_-а.

У развоју RustyArena видео-игре коришћени су различити библиотечки сандуци:
- _bincode_ - ефикаснa серијализацијa податка, кориснa за слање стања игра преко мреже @bincode.
- _serde_ - за флексибилну серијализацију и десеријализацију сложених структура података @serde.
- _tokio_ - асинхроно извршно окружење, олакшава конкурентно програмирање и комуникацију коришћењем асинхроних задатака @tokio.
- _gdext/godot_ - интеграција Rust кода у _Godot_ сцене уместо _GDScript_-а @gdext.
- _SQLx_ - сандуку који олакшава комуникацију са базом података @sqlx.
- _axum_ - једноставан фрејмворк за развој веб апликација @axum.
- _reqwest_ - HTTP клијент високог нивоа @reqwest.

У контексту мултиплејер игара, _Rust_ пружа стабилан и ефикасан начин за имплементацију серверске стране, асинхроне обраде порука и управљање ресурсима. Поменута библиотека _gdext_ нам омогућава коришћење _Rust_ кода и на клијентској страни.

== _Godot_ и _Godot extensions_

_Godot engine_ je софтвер отвореног кода (енг. _open-source_) који се користи за развој 2Д и 3Д игара бесплатан за коришћење. Познат је по својој једноставаности и архитектури заснованој на сценама. Једна од његових највећих предности је сценски систем (енг. _scene tree_), који представља хијерархију објеката (чворова) који заједно граде свет игре. Сваки чвор има одређену улогу -- може представљати визуелни елемент, део корисничког интерфејса (UI, енг. _user interface_), физички објекат или извор звука. Оваква структура омогућава модуларност и поновну употребу компоненти, што знатно олакшава развој и проширивост игре @godot.

У контексту приказа света, _Godot_ комбинује сцене у једно стабло чворова које се извршава током игре. Свака сцена може да садржи друге сцене, што омогућава да сложене сцене разложимо да подскуп сцена.

Подразумевани скриптни језик у _Godot_-у је _GDScript_, који је синтаксно сличан Пајтон-у и намењен је брзом развоју логике. Ипак за пројекте који захтевју високе перформансе или ближи контакт са системским ресурсима, постоји могућност коришћења других програмских језика преко _bindings_ система. _Godot_ је претежно писан у C++ језику, па _bindings_ за овај програмски су релативно документовани и подржани, док за језик по пут _Rust_-а и подршка и документација су доста слабији.

Овај приступ комбинује најбоље од оба света:
- _Rust_ обезбеђује ефикасност, стабилност и функционалност _borrow checker_-а @borrowchecker.
- _Godot_ пружа интерактивно окружење, визуелну презентацију и брз развој пројекта

Захваљујући томе, представља пример како се алати отвореног кода могу комбиновати ради постизања професионалних резултата уз потпуну контролу.

== Мрежна архитектура видео-игара

У почетку развоја мултиплејер видео-игара преовладавао је _peer-to-peer_ комуникациони модел. _Peer-to-peer_ модел представља децентрализован комуникациони модел, где сваки чвор у мрежи има једнака права, не постоји специјални чвор. Ослања се на потпуно повезану мрежасту топлогију (енг. _fully connected mesh topology_). Овај модел за комуникацију се још увек користи у појединим играма, пример су игре стратегије у реалном времену (RTS, енг. _real-time strategy_) @p2pspringnature. На слици @img:peer-to-peer је приказан изглед овакве архитектуре.

#figure(image("../slike/peer-to-peer.png", width: 70%),
caption: [
  _Peer-to-peer_ комуникациони модел
])<img:peer-to-peer>

Модел клијент-сервер представља дистрибуирану структуру апликације који раздваја задатке или количину посла на пружаоца ресурса и потрошача @client-server. Слика @img:klijent-server илуструје овакву архитектуру.

#figure(image("../slike/server_klijent.png", width: 70%),
caption: [
  Клијент-сервер архитектура
])<img:klijent-server>

У овом моделу постоји јасна подела улога:
- Сервер - управља стањем света игре, валидира улазе и синхронизује клијенте
- Клијенти - шаљу своје уносе, као што су покрет и акције, серверу и приказују стање света које сервер шаље

Ауторитативaн сервер (енг. _authoritative server_) предстаља централну компоненту која има потпуну контролу над светом игре и представља једини извор истине (енг. _single source of truth_). Свака акција клијента пролази кроз сервер који проверава њену испрвност, након чега сервер ажурира стање @client-server2. 

Овакав приступ омогућава:
- сигурност -- клијент не може изменити стање самостално
- доследност између свих играча
- једноставнију синхронизацију јер сервер диктира стање игре

Слика @img:apstraktna-arhitektura приказује архитектуру RustyArena пројекта на високом нивоу апстракције која обухвата неколико кључних компоненти:

- Сервер за игру (енг. _game server_) - имплементиран у _Rust_-у, задужен за управљање стањем света, обрадом логике и слање UDP порука клијентима.
- Клијент за игру (енг. _game client_) - реализован у _Godot engine_-у, шаље команде серверу и визуелизује добијене податке, често се може пронаћи назив "_dumb clients_".
- Сервер за аутентификацију (енг. _authentication server_) - независан модул који верификује играча пре приступа серверу за игру, чиме се осигурава контролисани приступ као и распоређивању играч у сесије.

#figure(image("../slike/dijgram_arhitekture_sistema.png", width: 70%),
caption: [
  Архитектура пројекта RustyArena на високом нивоу апстракције
])<img:apstraktna-arhitektura>

Ово даје добру основу за наставак пројекта, где би следећи корак био додавање више инстанци сервера. Сервер за аутентификацију се може користити као сервер који садржи информације о осталим гејм серверима. Када се корисник пријави на систем, аутентификациони сервер му може понудити листу тренутно активних сервера. Пример овакве архитектуре је приказан сликом @img:katalog-server.

#figure(image("../slike/katalog_server.png", width: 70%), 
caption: [
  Архитектура која укључује више гејм сервера
])<img:katalog-server>

== Технике за синхронизацију у мултиплејер играма 

У мултиплејер видео-играма, корисничко искуство (енг. _user experience_ - UX) је поред самог корисничког интерфејса повезано са начином на који систем обрађује комуникацију између клијента и сервера, и како синхронизује стање света између њих. Кашњење (енг. _latency_) и губитак пакета (енг. _packet loss_) могу значајно утицати на игру, неопходно је применити различите технике које минимизују њихов утицај на перцепцију играча. Слика @img:csp1 приказује овај проблем.

#figure(image("../slike/CSP1.png", width: 70%),
  caption: [
    Приказ проблеме које уводи кашњење одговора @csp
  ]
)<img:csp1>

Предикција на клијентској страни (енг. _client-side prediction_) - ова техника подразумева да уколико је игра довољно детерминистичка, клијент може да предвиди резултат одређене радње пре него што сервер потврди њену исправност и ажурира стање света. На пример када играч помери свог лика у одређеном правцу, клијент одмах прикзује ту промену, без чекања на одговор сервера @csp. Слика @img:csp2 приказује како ово изгледа.

#figure(image("../slike/CSP2.png", width: 70%), 
caption: [
    Основне идеје о предикцији на клијентској страни @csp
])<img:csp2>

Када сервер касније пошаље званично стање, клијент га упоређује с својом предикцијом, и уколико постоји разлика врши интерполацију и корекцију. Наведена техника важи под претпоставком да ће команда послата серверу бити упсешно извршена. Ово омогућва играчима да имају осећај тренутног одговора, чак и при већим кашњењима, али уводи додатан проблем. Ако корисник пошаље две команде једну за другом, пре него што је добио потврду од сервера за прву команда. Ово може произвести ефекат да играч "скаче" током игре @csp. Слика @img:csp3 описује овај проблем.

#figure(image("../slike/CSP3.png", width: 70%), 
caption: [
  Проблема који настаје наивном имплементацијом @csp
])<img:csp3>

Усаглашавање са сервером (енг. _server reconciliation_) - је техника која омогућава клијенту да након исправке локалног стања, коришћењем података добијених од сервера, поново примени све радње које су се догодиле у међувремену. То спречава нагле скокове и промене положаја играча (енг. _jittering_). У пракси, клијент чува историју својих улаза и када добије податке о стању на серверу, он враћа стање на серверско, а затим поново репродукује све улазе који су се догодили након тог тренутка @csp. На слици @img:sr је приказано шта ова техника решава.

#figure(image("../slike/SR.png", width: 70%),
caption: [
  Проблем који се решава техником усаглашавања са сервером @csp
])<img:sr>

== Функционални захтеви

*RustyArena* је мултиплејер видео-игра са аспектом борбе у реалном времену. Изгледом подсећа на чувену игру Астероиди (енг. _Asteroids_). Сваки играч управља свемирским бродом, где је циљ игре уништити бродове осталих играча и истовремено избегавати астероиде који се крећу по мапи.

Систем испуњава основне функционалне захтеве:
- Омгућити кориснику регистрацију на систем коришћењем корисничког имена и лозинке
- Омогућити кориснику да се пријави на систем како би могао покренути игру
- Основни гејмплеј игре који обухвата:
  - кретање играча на мапи
  - могућност да корисник пуца на друге играче
  - животне поене
  - астероиде које играчи избегавају или уништавају
  - ресетовање играча након што је његов брод уништен

== Нефункционални захтеви

Нефункционални захетви које систем обухвата:
- Систем подржава рад са више истовремених клијената
- Синхронизација између клијената и сервера
- Видео-игра треба да буде стабилна

