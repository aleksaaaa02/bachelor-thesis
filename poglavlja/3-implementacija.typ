#import "../funkcije.typ": todo

= Имплементација
<implementacija>

У овом поглављу описана је детаљнија имплементација игре. Архитектура и имплементација апликације зависи од самог домена, односно конктретне видео-игре која се имплементира и њеног гејмплеја (енг. _gameplay_). Ако посматрамо пример неке игре са картама попут игре UNO#footnote[https://www.unorules.com/], за овкав тип игре није нам критично време одзива сервера. Односно ако одговор закасни и пар секунди, играч се неће осетити ошећено, као да је игра намештена. Код других игара које захтевају брзо ажурирање стања света, попут игре _Valorant_#footnote[https://playvalorant.com/en-gb/], мало кашњење може произвести лоша корисничка искуства. Због тога је важан добар одабир протокола за комуникацију и планирање унапред, јер различити жанрови видео-игара захтевју другачију архитектуру система.

== Дељени код 

_Bincode_ и _serde_ су _Rust_ библиотечки сандуци који олакшавају серијализацију и десеријализацију _Rust_ типова, као и самостално дефинисаних структура и енумерација. Све заједничке структуре које се користе у комуникацији смештене су у пројекат _common_ како би смањили дуплирање кода. Све што се серијализује мора да имплементира одговарјуће _Rust_ особине (енг. _traits_) _Serialize_ и _Deserialize_. Пример дефинисаног модела је дат у листингу @list:packet-primer.

#figure(```rust
use bincode::{Decode, Encode};

#[derive(Encode, Decode, Debug, Clone)]
pub struct Player {
    pub id: u32,
    pub x: f32,
    pub y: f32,
    pub rotation: f32,
    pub vx: f32,
    pub vy: f32,
    pub hp: u16,
    pub last_shot_ms: u64,
    pub fire_rate_ms: u64,
    pub last_processed_input_seq: u32,
}
```, caption: [Пример пакета који се користи за комуникацију
])<list:packet-primer>

== Серверска страна

_Game server_ је ауторитативан сервер на коме се врши симулација света игре. При покретању, сервер отвара два сокета (енг. _socket_), један од њих је намењен за комуникацију преко TCP-a док је други намењен за комуникацију преко UDP-a. Комуникација преко, односно операције читања и писања порука могу бити дуге и блокирајуће операције, ово се може решити ако сервер имплементирамо као вишенитни сервер (енг. _multi-threaded_). Коришћењем _Tokio_ сандука можемо раздвојити обраду порука у одвојене асинхроне задатке. Конкретни асинхрони задаци подразумевају:
- Обраду TCP захтева и слање одговара
- Обраду долазних UDP захтева и прослеђивање истих симулацији света
- Емитовање (енг. _broadcasting_) стања света свим повезаним играчима
- Симулацију света игре, такозвани "_game loop_"

=== Обрада захтева

Обрада TCP захтева обухвата пријем порука, обради и по потреби прослеђивању ка нити која симулира игру коришћењем канала (енг. _channel_). У тренутној имплементацији се овај механизам користи како би играч обавестио сервер да жели да приступи игри, али је могуће додати нове функционалност које захтевају поузданост.

Обрада долазних UDP захтева је слична обради код TCP захтева. Долазне поруке су дефинисане у пројекту _common_, које се путем канала за асинхрону комуникацију прослеђују даље задатку која симулира игру. Ове поруке су заправо команде које играчи шаљу како би мењали стање света. Пре него што дође до промене стања, команда се валидира како бисмо спречили злонамерне кориснике да варају у играма и заобилазе правила игре. На листингу @list:komanda прикзан је модел података команде која се шаље када корисник притисне одговарајући тастер.

#figure(
    ```rust
#[derive(Encode, Decode, Clone, Debug, Copy)]
pub enum InputAction {
    RotateLeft,
    RotateRight,
    Shoot,
    Thrust,
    Hello,
}

#[derive(Encode, Decode, Clone, Debug)]
pub struct PlayerInput {
    pub id: u32,
    pub seq: u32,
    pub action: InputAction,
}
    ```, 
    caption: [
        Модел података команде
    ])<list:komanda>

Иако корисник приликом првог приступа серверу шаље TCP поруке, играч мора послати још једну поруку преко UDP конекције како би сервер био обавештен на коју адресу (IP и порт) треба да шаље стање света како би играчи имали ажуран приказ игре. Приликом прве команде, клијент јавља серверу да је спреман да приказује игру кориснику  и на коју адресу треба да га обавештава о стању игре. За поступак обавештавања на серверу задужен је _broadcasting_ асинхрони задатак. Он периодично емитује стање света играчима који су забележени као активни када нит која симулира свет то затражи.

=== _Game loop_

_Game loop_ је бесконачна петља која симулира свет и правила игре. Она ради фиксном фреквенцијом, која одређује број извршених итерација у једној секунди. Често се узима вредност од 60Hz, што значи да једна итерација траје око 16ms. Да бисмо осигурали да симулација не тече брже, проверавамо време између итерација петљи и, по потреби, успаваљујемо нит на преостали део периода. Псеудо код који представља овакву архитектуру дат је испод.

#figure(
```rust
loop {
    // Провери да ли постоји нови играч
    // Провери да ли постоје нове команде
    // Симулирај свет за једну итерацију
    // Емитуј ново стање света свим активним играчима
    // Сачекај преостали период ако за тим има потребе
}
```
, caption: [
    Апстрактан преглед _game loop_-а
])<list:gameloop-code>

Проверавамо прво да ли постоје нови играчи који желе да се прикључе игри, након чега проверавамо да ли постоје команде од стране играча које треба обрадити. На крају ажурирамо стање игре и шаљемо тренутно стање свим активним играчима. Како је тренутна сепцификација игре једноставна, можемо приуштити да у свакој итерацији емитујемо целокупно стање света, ово се касније може изменити и оптимизовати у зависности од будућих захтева.

Унутар сваке итерације петље имамо ажурирање света, симулирамо физику, кретања, покушавако да детектујемо колизије (енг. _collision detection_) и након тога проверавмо правила игре, као што је правило о смањивању животних поена (енг. _health points_).

=== Ентитети и њихова ажурирања

Конкретно код RustyArena игре прво ажурирамо позиције ентитета, односно играча, астероида и метака. Играч има могућност ротације, као кретања лево и десно, и има могућност да се лансира и креће у смеру и правцу одређеним његовом положајем. Положај играча је представљен _x_ и _y_ координатама и углом ротације - угао који заклапа са позитивним делом _x_-осе. Када играч притисне тастер за кретање напред сервер заправо том играчу мења брзину кретања по осама у односну на његов положај, његов глобални положај у игри ажурира се тек када се ажурира свет. Када играч отпусти тастер за кретање напред, брод се не зауставља одмах већ наставља кретање, али успорава постпено до заустављања. Свет је ограничен са 4 стране, тако да играч не може прећи изван тих граница већ ће привидно деловати као да постоји невидљиви зид. Имплементација кретања дата је у листингу @list:kretanje.

#figure(
    ```rust
pub fn update_player_position(&mut self) {
    // Померање енетитета по x и y оси
    self.x += self.vx;
    self.y += self.vy;
    
    // У случају да прелазе границе терана постави их на ивицу
    self.x = self.x.clamp(-800.0, 800.0);
    self.y = self.y.clamp(-600.0, 600.0);

    // Симулирај успоравање
    self.vx *= 0.9;
    self.vy *= 0.9;
}
    ```,
    caption: [Кретање играча])<list:kretanje>

Осим кретања, играч има могућност да пуца како би уништио бродове других играча. Када играч пртисне тастер за пуцање, сервер на основу координата и ротације брода рачуна правац и брзина кретања метка по _x_ и _y_ оси. Поред ових параметара бележи се и пређени пут метка како бисмо га након неког времена да уништили, као и време последње испаљеног метка, како бисмо ограничили број пуцања.

Поред метака и бродова као игача, имамо и астероиде. Астероиди уводе ефекат насумичности који повећава изазов игре како игра не би брзо досадила. Иницијализују се на следећи начин:
- На случајан начин се бира једна ивица света на којој ће се астероид иницијализовати.
- Након што је ивица одабрана, на случајан начин бира се положај на тој ивици и додајемо одређену маргину у случају да се неки играч нађе на ивици.
- За правац кретања астероида се прво на случајан начин бира неко од играча, након чега се астероиду додељује брзина кретања која тако што се прво пронађе јединични вектор између играча и почетне позиције астероида након чега се множи са брзином кретања. 
Као и код испаљених метака постоји пређени пут који се рачуна при свакој итерацији чија вредност се користи за уклањање астероида који прелазе неку границу. Само кретање испаљених метака и астероида је нешто једноставније, односно не постоји скалирање брзине током времена како бисмо симолулирали успоравање.

=== Детекција колизија

Након ажурирања положаја свих ентитета, сервер проверава да ли је дошло до колизија између одређених ентитета. У имплементацији коришћен је једноставан алгоритам, посматра се удаљеност центара између ентиета, и уколико је раздаљина мања од неког прага сматра се да су се ентиетити сударили. Конкретно сервер проверава:
- Да ли је неки метак погодио неки астероид
- Да ли је неки метак погодио неког играча, под условом да то није играч који је испалио метак
- Да ли је неки астероид погодио неког играча

Свака колизија се бележи након чега се примењују правила игре. Конкретна правила игре су следећа:
- Ако је метак погодио астероид, и астероид и метак се тада уништавају.
- Ако је метак погодио неког играча, метак се уништава док се погђеном играчу одузимају животни поени. Конкретна се одузима 20 поена, али је ову вредност могуће конфигурисати.
- Ако је астероид погодио неког играча, астероид се уништава, а играчу се смањује број животних поена за одређену суму.
- Ако неко од активних играча има 0 животних бодова, сматрати да је он уништен и иницијализовати га на нову позицију.
- Иницијализују астероиде ако постоје услови за то. Конкретно астероиде инцијализујемо након сваких 1000ms како не бисмо преплавили игру астероидима. Ово је такође нешто што се може прилагодити.

== Клијентска страна

Сама имплементација у _Godot_-у заснива се на томе што алат допушта проширивање путем екстензија за _Rust_. Уместо да се код компајлира у апликацију или библиотечки сандук, заправо креирамо динамичку библиотеку која излаже интерфејс у програмском језику C. Динамичка библиотека се учитава у _Godot_ у време извршавања, преко _GDExtension_ интерфејса.

Олакшавајућа околност је то што можемо користити сандуке попут _tokio_ и _reqwest_ на клијентској страни. Ово је посебно битно јер омогућава неблокирајуће слушање порука од главног сервера. Из перспективе корисника, генерално није пожељно да блокирамо игру док чекамо или обрађујемо одговор од сервера. Постоје изузеци ако је одговор од сервера потребан за даљи наставак, али и у таквим ситуацијама пожељно је не блокирати програм у потпуности.

=== Основне функционалности

Елементи у _Rust_-у који се користе у _Godot_ морају да имплементирају одређене особине или буду одређеног типа.

#figure(
```rust
#[derive(GodotClass)]
#[class(base=CharacterBody2D)]
pub struct PlayerWrapper {
    base: Base<CharacterBody2D>,
    ...
}
```
, caption: [
    Пример наслеђивања _Godot_ класе у _Rust_ коду
])<list:godot_struct>

Особине које су наведене у исечку кода означавају да дата структура наслеђује одређену _Godot_ класу. Иако _Rust_ није објектно оријентисани језик, на овај начин се симулира наслеђивање. Поред дефинисања структура, може се имплементирати интерфејс који наслеђена класа поседује. Ово је некада обавезно, посебно `init` метода која се користи за иницијализацију чвор. Пример је дат у листингу @list:interfejs.

#figure(
```rust
#[godot_api]
impl ICharacterBody2D for PlayerWrapper {
    fn init(base: Base<CharacterBody2D>) -> Self {
        Self {
            base,
            ...
        }
    }

    fn ready(&mut self) {
      ...
    }

    fn process(&mut self, delta: f64) {
      ...
    }

    fn physics_process(&mut self, delta: f64) {
      ...
    }
}

#[godot_api]
impl PlayerWrapper {
    #[func]
    pub fn do_something(&mut self) {
      ...
    }
}
```,caption: [
    Пример функција које _Godot_ структура имплементира
])<list:interfejs>

Важно је разумети ове структуре јер већина алата за развој видео игара се базира на њима:
- _ready_ - функција се позива само једном када сцена први пут постане видљива унутар _scene tree_-а.
- _process_ - функција се позива сваки пут када се фрејм (енг. _frame_) исцртава, варира од брзине процесора.
- _physics_process_ - функција се позива на фиксан период, погодан за обраду и симулацију физике.

Поред имплементације интерфејса за неку _Godot_ класу, могу се дефинсати и додатне методе унутар имплементационог блока дефинисане структуре.

=== Мрежна комуникација

RustyArena поседује две структуре чији фокус је комуникација са серверима. Прва структура је _NetworkClient_ који се користи за комуникацију са сервером на коме се игра симулира. При покретању игре учитава се адресе на којима се налазе сервери. Код у листингу @list:serverkonekcija представља имплементацију отварања сокета за UDP комуникацију. За адресу наведена је локална адреса (0.0.0.0), док за порт је постављена нула што означава коришћење било ког слободног порта.

#figure(
```rust
...
pub fn connect_to_server(&mut self) {
    let addr = &self.game_server_address_udp; // адреса је учитана у објекту пре позива методе
    let sock_future = async move {
        match UdpSocket::bind("0.0.0.0:0").await { // отварамо сокет 
            Ok(sock) => {
              // враћање резултата
            }
            Err(_) => {
              // руковање грешком
            }
        }
    };
    let socket = AsyncRuntime::block_on(sock_future); // чектање на одговор да ли је сокет успешно отворен
}
...
```, caption: [
    Код који отвара конекцију са сервером
])<list:serverkonekcija>

Такође при слању команди на притисак тастера иницијализујемо посебан задатак за слање поруке како би игра остала респонзивна. Сервер је имплементиран тако да не враћа одговор кориснику на његову команду, већ само мења стање игре, а корисник ће видети промене када сервер пошаље стање игре свим играчима.

#figure(
```rust
    pub fn send_input(&self, id: u32, seq: u32, action_code: u32) {
        let socket = self.socket.clone();
        let input = PlayerInput { // спремање команде
            ...
        };

        let input_bytes = ... // серијализација команде у низ бајтова
        AsyncRuntime::spawn(async move {
            let _ = socket.unwrap().send(&input_bytes).await; // слање преко мреже у посебном асинхроном задатку
        });
    }
```, caption: [
    Код који обаља слање команде
])<list:slanje_komande>

Имплементација функције која шаље иницијалну поруку преко TCP конекције је дата следећем исечку кода. Сервер као одговор шаље исти идентификатор који је клијент послао као потврду да је сервер постао свестан новог играча.

#figure(
```rust
    pub async fn send_handshake(&mut self) -> Result<u32, std::io::Error> {
        let auth_address = ... // добављање адресе и порта на коме сервер ослушкује TCP саобраћај
        let mut stream = ... // отварање конекције за пријем и слање

        let id = self.controller_id;

        let request = ... // серијализација идентификатора
        stream.write_all(&request).await?; // слање идентификатора

        let mut buffer = ... // бафер у коме смештамо одговор
        stream.read_exact(&mut buffer).await?; // читање одговора
        let player_id = ... // конверзија у одговарајући тип (u32)
        Ok(player_id) // повратна вредност
    }
```, caption: [
    Иницијална комуникација са сервером - _Handshake_
])<list:handshake>

Након што је све иницијализовано, клијент је спреман да слуша поруке које сервер доставља како би визуализово стање игре. Користи се канал за асинхрону комуникацију. Оно што може бити проблематично је што типове које _Godot_ пружа нису безбедни да се користе у конкурентним програмима, тако да ако желимо да емитујемо сигнал или приступимо неком _Godot_ типу, то није могуће постићи на једноставан начин. Једно решење које је имплементирано је слање резултата путем канала у функцију `process` која проверава да ли постоји порука на коју треба одреаговати.

#figure(
```rust
pub fn start_listening(&mut self) -> Option<UnboundedReceiver<GameWorld>> {
    let listen_sock = socket.clone();
    let (tx, rx) = unbounded_channel(); // канал који се користи за асинхрону комуникацију

    AsyncRuntime::spawn(async move {
        ...
        loop {
            match listen_sock.recv(&mut buf).await {
                Ok(len) => {
                    if let Ok((world, _)) =
                        bincode::decode_from_slice::<GameWorld, _>(&buf[..len], config) // конверзија из низа бајтова у конкретну структуру
                    {
                        if tx.send(world).is_err() { // слање поруке кроз канал за асинхрону комуникацију
                            break;
                        }
                    }
                }
                Err(e) => {
                    godot_error!("Failed to receive snapshot: {}", e);
                    break;
                }
            }
        }
    });

    Some(rx) // канал који се користи у функцији 'process'
}
```, caption: [
    Функција која отпочиње асинхрони задатак који се бави читањем пристиглог UDP саобраћаја
])<list:slusanje>

Друга структура која је намењена за комуникацију је _NetworkAPI_ која се фокусира на комуникацију са сервером за аутентификацију. Методе која ова стркутура поседује су `login` и `register` које се баве пријавом и регистрацијом на систем. За комуникцију између чворова, _Godot_ поседује посебан механизам сигнала. Овај мехнизам заправо омогућава имплементацију _observer_ обрасца. У наведеним методама коришћењем _reqwest_ сандука, шаље се захтев аутентификационом сервер и чека се одговор у посебној нити. Када одговор пристигне шаље се `process` методи _NetworkAPI_ чвора коришћењем асинхроних канала за комуникацију. Затим се проверава тип одговора који је пристигао, и емитује се одговарајући сигнал. Сви елементи, функције које су претплаћене и слушају задати сигнал, ће се ивршити. На овај начин можемо обезбедити ефикасну асинхрону комуникацију без блокирања апликације. 

Разлог за раздвајање на две структуре је само због лакше одрживости, ако је потребно проширити једну страну.

=== Обрасци у развоју клијентске стране

_Singleton_ образац се користи када је потребно да постоји једна инстанца класе у систему. Данас се често сматра анти-обрасцем (енг. _anti-pattern_) јер је тешко да се _mock_-ује приликом тестирања, a поред тога глобални објекти су често лош дизајн. Код развоја игара овај образац се може применити, добар пример је када играч треба прећи са једног нивоа на други, а желимо да сачувамо контекст и податке тренутног играча. Помоћу овог обрасца можемо чувати податке који су дељени, односно различите сцене захтевају приступ подацима или неким функционалностима. RustyArena имплементира овај образац на два места:
- _AsyncRuntime_ - омогућава да креирамо само један _tokio Runtime_  и једноставније креирање нових задатака.
- _NetworkClient_ - омогућава да код одржавамо чистим јер различите сцене захтевају позиве метода ове структуре.

Проблеми који су настали приликом израде овог дела задатка су спорије решавани због тежине да се дебагује код који се конкуретно извршава, посебно на клијентској страни. Технике попут исписа порука на одређеним местима у коду овде неће радити, односно порука неће бити исписана у _Godot_ конзоли. Дешава се да програм настви са извршавањем, иако је наишао на грешку.

== Пробелем синхронизације 

У мултиплејер играма неопходно је обезбедити да клијен и сервер остану синхронизовани, чак и када се команде извршавају асинхроно. Сервер је имплементиран тако да не шаље одговор на извршену команду, односно клијент не добија одговор од сервера за послату команду и да ли се она извршила. Разлог зашто је на овај начин одрађена имплементација је то што је игра борба у реалном времену и број пакета који се размењује огроман. Због тога је као протокол за комуникацију између клијената и сервера изабран UDP, уместо TCP, како би се смањило кашњење и избегли проблеми са редоследом испоруке.

Клијенту је доступно стање света на основу кога он може да закључи да ли се његова команда извршила или тако што ће приметити да је та команда донела промене. У овој игри, свака команда коју клијент шаље серверу садржи редни број команде, број који се инкрементује за сваку наредну команду, који означава редослед њеног слања. Иако не враћа одговор на команду, сервер за сваког играча чува информацију о последњој обрађеној команди.

Када клијент добије ново стање света од сервера, он  проверав у својој локалној историји команди која је послења команда коју је сервер обрадио. Све команде које су послте пре тог тренутка се одбацују, док се све накнадне команде поново примењују. На овај начин клијент коригује своју предикцију и остаје усклађен са серверским стањем, без потребе за експлицитним потврдама након сваке акције.

Исечак кода који имплементир овај механизам дат је у листингу @list:csp-sr.

#figure(
    ```rust
pub fn reconcile_with_server(&mut self, server_player: Player, delta: f64) {
    // ажурирање података корисника пристиглих са сервера
    ...

    // остављамо само команде које нису још увек обрађене од стране сервера
    let last_ack = server_player.last_processed_input_seq; 
    self.pending_inputs.retain(|input| input.seq > last_ack); 

    // команде које још увек нису обрађене извршавамо локално 
    let unack = self.pending_inputs.clone();
    for input in unack.iter() {
        self.apply_local_input(input.action, delta);
    }
}

pub fn apply_local_input(&mut self, action: InputAction, delta: f64) {
    match action {
        // за акције корисника дефинишемо локалко понашање, због једноствности користићемо имплементацију сличну серверској
    }
    // по потреби одрадити додатна ажурирања
    self.data.update_player_position();
}
    ```
    ,caption: [
        Предикција са клијентске стране и синхронизација са сервером
])<list:csp-sr>

== Сервер за аутентификацију

Сервер за аутентификацију имплементиран је коршћењем _Tokio_ _Axum_ и _SQLx_ сандука. Његова главна сврха је да омогући корисницима приступ систему путем регистрације и пријаве, пре него што започну игру. 

Кориснички подаци се чувају у _PostgreSQL_ бази података, при чему се лознике хешују (енг. _hashing_) како би се повећала безбедност. При свакој успешној пријви, сервер враћа индетификатор, који клијент касније користи за идентификацију током комуникације са сервером игре. Овај приступ је поједностављен и погодан за развојну фазу система, јер омогућава једноставну интеграцију са клијентом.

Комуникација са сервером обавља се путем HTTP протокола, а подаси се размењују у JSON формату. У будућности, овај систем може бити проширен коришћењем сесијских токена ради боље безбедности и контроле приступа.

За потребе развоја и тестирања обезбеђена је скрипта ``init.sql`` која креира потребне табеле. У _Rust_-у, ред у табели корисника представљен је структуром приказаном у листингу @list:korisnikbaza, док је пример DTO објекта дат у листингу @list:dto.

#figure(
    ```rust
#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct User {
    pub id: i32,
    pub username: String,
    pub password_hash: String
}
    ```, caption: [
    Модел података приказан у Rust-у
])<list:korisnikbaza>

#figure(
    ```rust
#[derive(Deserialize, Serialize, Clone)]
pub struct LoginRequest {
    pub username: String,
    pub password: String
}

#[derive(Deserialize, Serialize, Clone)]
pub struct AuthResponse {
    pub id: i32,    
}
    ```, caption: [
    DTO објекти у Rust-у
])<list:dto>